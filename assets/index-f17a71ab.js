(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const a of r)if(a.type==="childList")for(const n of a.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&i(n)}).observe(document,{childList:!0,subtree:!0});function s(r){const a={};return r.integrity&&(a.integrity=r.integrity),r.referrerPolicy&&(a.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?a.credentials="include":r.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function i(r){if(r.ep)return;r.ep=!0;const a=s(r);fetch(r.href,a)}})();var y=1e-6,E=typeof Float32Array<"u"?Float32Array:Array,z=Math.PI/180;function P(e){return e*z}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});function g(){var e=new E(16);return E!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function S(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function T(e,t,s){var i=Math.sin(s),r=Math.cos(s),a=t[0],n=t[1],l=t[2],p=t[3],f=t[4],c=t[5],h=t[6],d=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*r+f*i,e[1]=n*r+c*i,e[2]=l*r+h*i,e[3]=p*r+d*i,e[4]=f*r-a*i,e[5]=c*r-n*i,e[6]=h*r-l*i,e[7]=d*r-p*i,e}function C(e,t,s,i,r){var a=1/Math.tan(t/2),n;return e[0]=a/s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,r!=null&&r!==1/0?(n=1/(i-r),e[10]=(r+i)*n,e[14]=2*r*i*n):(e[10]=-1,e[14]=-2*i),e}var O=C;function R(e,t,s,i){var r,a,n,l,p,f,c,h,d,o,u=t[0],v=t[1],m=t[2],w=i[0],M=i[1],x=i[2],b=s[0],A=s[1],B=s[2];return Math.abs(u-b)<y&&Math.abs(v-A)<y&&Math.abs(m-B)<y?S(e):(c=u-b,h=v-A,d=m-B,o=1/Math.hypot(c,h,d),c*=o,h*=o,d*=o,r=M*d-x*h,a=x*c-w*d,n=w*h-M*c,o=Math.hypot(r,a,n),o?(o=1/o,r*=o,a*=o,n*=o):(r=0,a=0,n=0),l=h*n-d*a,p=d*r-c*n,f=c*a-h*r,o=Math.hypot(l,p,f),o?(o=1/o,l*=o,p*=o,f*=o):(l=0,p=0,f=0),e[0]=r,e[1]=l,e[2]=c,e[3]=0,e[4]=a,e[5]=p,e[6]=h,e[7]=0,e[8]=n,e[9]=f,e[10]=d,e[11]=0,e[12]=-(r*u+a*v+n*m),e[13]=-(l*u+p*v+f*m),e[14]=-(c*u+h*v+d*m),e[15]=1,e)}const F=new Float32Array([1,-1,0,-1,-1,0,0,1,0]),L=new Float32Array([1,0,0,1,0,1,0,1,0,0,1,1]),U=new Uint16Array([0,1,2,0]);class V{constructor(t){this.viewTranslation=[0,0,5],this.zNear=.1,this.zFar=1e3,this.sampleCount=4,this.onMouseWheel=s=>{let i=this.viewTranslation[2]+=s.deltaY*.01;i=Math.max(this.zNear,Math.min(this.zFar,i)),this.viewTranslation[2]=i},this.render=()=>{T(this.modelMatrix,this.modelMatrix,P(.5)),this.updateUniformBuffer(),this.encodeCommands(),requestAnimationFrame(this.render)},this.canvas=t,this.modelMatrix=g(),this.viewMatrix=this.createViewMat(),this.projectionMatrix=this.createPerspectiveMat()}createPerspectiveMat(){const t=g(),s=this.canvas.width/this.canvas.height;return O(t,P(45),s,this.zNear,this.zFar),t}createViewMat(){const t=g();return R(t,this.viewTranslation,[0,0,0],[0,1,0]),t}resize(t,s){(t!==this.presentationSize.width||s!==this.presentationSize.height)&&(this.canvas.width=t,this.canvas.height=s,this.presentationSize={width:t,height:s,depthOrArrayLayers:1},this.projectionMatrix=this.createPerspectiveMat(),this.resizeSwapchain())}async initialize(){const t=navigator.gpu;if(!t)return console.error("No WebGPU support navigator.gpu not available!"),!1;const s=await t.requestAdapter();return console.log(s.limits),this.device=await s.requestDevice(),this.queue=this.device.queue,this.canvas.style.display="block",this.canvas.addEventListener("wheel",this.onMouseWheel),this.presentationSize={width:this.canvas.width,height:this.canvas.height,depthOrArrayLayers:1},this.presentationContext=this.canvas.getContext("webgpu"),this.presentationFormat=t.getPreferredCanvasFormat(),this.presentationContext.configure({device:this.device,format:this.presentationFormat,alphaMode:"opaque"}),new ResizeObserver(r=>{Array.isArray(r)&&this.resize(r[0].contentRect.width*window.devicePixelRatio,r[0].contentRect.height*window.devicePixelRatio)}).observe(this.canvas),!0}createBuffer(t,s){try{const i=this.device.createBuffer({mappedAtCreation:!0,size:t.byteLength,usage:s}),r=i.getMappedRange();return(t instanceof Float32Array?new Float32Array(r):new Uint16Array(r)).set(t),i.unmap(),i}catch(i){console.error(i)}}updateUniformBuffer(){const t=new Float32Array([...this.modelMatrix,...this.createViewMat(),...this.projectionMatrix]);this.queue.writeBuffer(this.uniformBuffer,0,t.buffer)}async loadShader(t){const s=await fetch(t);return this.device.createShaderModule({code:await s.text()})}resizeSwapchain(){this.renderTarget!==void 0&&(this.renderTarget.destroy(),this.depthTarget.destroy()),this.renderTarget=this.device.createTexture({size:this.presentationSize,sampleCount:this.sampleCount,format:this.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.renderTargetView=this.renderTarget.createView(),this.depthTarget=this.device.createTexture({size:this.presentationSize,sampleCount:this.sampleCount,format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.depthTargetView=this.depthTarget.createView()}encodeCommands(){const t={view:this.presentationContext.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"};this.sampleCount>1&&(t.view=this.renderTargetView,t.resolveTarget=this.presentationContext.getCurrentTexture().createView());const s={view:this.depthTargetView,depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store",stencilLoadOp:"clear",stencilClearValue:0,stencilStoreOp:"store"},i={colorAttachments:[t],depthStencilAttachment:s};this.commandEncoder=this.device.createCommandEncoder(),this.passEncoder=this.commandEncoder.beginRenderPass(i),this.passEncoder.setPipeline(this.renderPipeline),this.passEncoder.setBindGroup(0,this.uniformBindGroup),this.passEncoder.setViewport(0,0,this.canvas.width,this.canvas.height,0,1),this.passEncoder.setScissorRect(0,0,this.canvas.width,this.canvas.height),this.passEncoder.setVertexBuffer(0,this.positionBuffer),this.passEncoder.setVertexBuffer(1,this.colorBuffer),this.passEncoder.setIndexBuffer(this.indexBuffer,"uint16"),this.passEncoder.drawIndexed(3,1,0,0,0),this.passEncoder.end(),this.queue.submit([this.commandEncoder.finish()])}async initializeResources(){this.positionBuffer=this.createBuffer(F,GPUBufferUsage.VERTEX),this.colorBuffer=this.createBuffer(L,GPUBufferUsage.VERTEX),this.indexBuffer=this.createBuffer(U,GPUBufferUsage.INDEX);const t=new Float32Array([...this.modelMatrix,...this.viewMatrix,...this.projectionMatrix]);this.uniformBuffer=this.createBuffer(t,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),this.vertexModule=await this.loadShader("./shaders/basic.vert.wgsl"),this.fragmentModule=await this.loadShader("./shaders/basic.frag.wgsl");const s={shaderLocation:0,offset:0,format:"float32x3"},i={shaderLocation:1,offset:0,format:"float32x4"},r={attributes:[s],arrayStride:4*3,stepMode:"vertex"},a={attributes:[i],arrayStride:4*4,stepMode:"vertex"},n={depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"},l=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]});this.uniformBindGroup=this.device.createBindGroup({layout:l,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]});const p={bindGroupLayouts:[l]},f=this.device.createPipelineLayout(p),c={module:this.vertexModule,entryPoint:"main",buffers:[r,a]},h={format:"bgra8unorm",blend:{alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},writeMask:GPUColorWrite.ALL},d={module:this.fragmentModule,entryPoint:"main",targets:[h]},o={layout:f,vertex:c,fragment:d,primitive:{topology:"triangle-list",frontFace:"cw",cullMode:"none"},depthStencil:n,multisample:{count:this.sampleCount}};this.renderPipeline=this.device.createRenderPipeline(o)}async start(){if(await this.initialize())this.resizeSwapchain(),await this.initializeResources(),this.render();else{const t=document.getElementById("error");t.style.display="block"}}}const G=document.getElementById("webgpu_canvas"),N=new V(G);N.start();
